// MoonWalk это высокопроизводительный движок основанный на WGPU и предназначенный для
// рендеринга пользовательского интерфейса и игровых 2D сцен. MoonWalk распространяется
// свободно под лицензией EPL 2.0 (Eclipse public license). Подробнее про лицензию
// сказано в файле LICENSE (Корень репозитория). Copyright 2025, UpdateDeveloper.
//
// Данный файл предоставляет публичный API рендер движка (В том числе и FFI) для
// использования в других проектах. В этом файле не должна содержаться какая-либо
// логика кроме подключения модулей и объявления публичных функций.
//
// Смотрите подробную документацию здесь: [ССЫЛКА]

pub mod error;
mod rendering;
mod objects;
mod batching;
mod textware;
mod easy_gpu;

use raw_window_handle::{HasDisplayHandle, HasWindowHandle};
use glam::{Vec2, Vec4};
use wgpu::SurfaceError;

pub use crate::objects::ObjectId;
use crate::rendering::renderer::MoonRenderer;

/// Основная структура движка которая содержит рендерер. Конструктор new
/// принимает окно (Которое можно получить через winit), ширину окна и
/// высоту окна. 
/// Пример (new возвращает result, необходимо обработать результат): 
/// let moonwalk = MoonWalk::new(static_window, 1280, 720).unwrap();
/// 
/// Совет: Вы можете получить статичное окно с помощью такого кода
/// let window = event_loop.create_window( ... ).unwrap();
/// let static_window: &'static Window = Box::leak(Box::new(window));
pub struct MoonWalk {
    renderer: MoonRenderer,
}

impl MoonWalk {
    pub fn new(
        window: &'static (impl HasWindowHandle + HasDisplayHandle + Send + Sync),
        width: u32, height: u32,
    ) -> Result<Self, error::MoonWalkError> {
        let renderer_result = MoonRenderer::new(
            window, width, height,
        );

        let renderer = match renderer_result {
            Ok(r) => r,
            Err(e) => {
                return Err(e);
            }
        };

        Ok(Self { renderer })
    }

    /// Функция чтобы установить размер viewport'а (Область, куда идёт рисование)
    /// Если пользователь вашего приложения изменит размер окна (Через оконный менеджер) 
    /// то область рисования не уменьшится и не увеличиться.
    /// Решение: слушать событие изменения размеров окна и вызывать mw.set_viewport
    /// передавая туда новую ширину и высоту окна.
    pub fn set_viewport(&mut self, width: u32, height: u32) {
        self.renderer.resize(width, height);
    }

    /// Scale Factor нужно взять у winit либо другой библиотеки
    /// он необходим чтобы преобразовать логические размеры окна
    /// в физические (Иначе полноэкранного режима не будет на телефонах)
    pub fn set_scale_factor(&mut self, scale: f32) {
        self.renderer.set_scale_factor(scale);
    }

    /// Функция для рендеринга всех элементов которые накопил движок.
    /// Вызывать нужно КАЖДЫЙ КАДР, но не делать этого в бесконечном
    /// цикле (While/loop). Вместо этого лучше использовать встроенное
    /// событие в библиотеку для работы с окнами. Пример для winit:
    /// WindowEvent::RedrawRequested => { ... }
    /// Первый аргумент это структура Vec4 из крейта GLAM, сюда нужно
    /// передать цвет которым будет заливаться экран.
    pub fn render_frame(&mut self, _clear_color: Vec4) -> Result<(), SurfaceError> {
        self.renderer.render()
    }

    /// Функция для создания прямоугольника и получения его ID.
    /// Важное предупреждение: НЕ СОЗДАВАЙТЕ ОБЪЕКТЫ КАЖДЫЙ КАДР
    /// ЕСЛИ ЭТО НЕ ВАША ПРЯМАЯ ЦЕЛЬ. После создания объекта он
    /// существует в кэше рендер движка и просто отправляется на
    /// отрисовку в момент вызове render_frame, вам нужно только
    /// создать объект один раз, получить его ID (структура ObjectId)
    /// и работать с ним используя методы конфигурации
    pub fn new_rect(&mut self) -> ObjectId {
        self.renderer.new_rect()
    }

    /// Функция для изменения позиции любого объекта по его ID
    /// (Структура ObjectId которую можно получить вызвав new_* функцию)
    /// принимает ID объекта и структуру Vec2 для описания 2D позиции
    /// в мировой системе координат, (0, 0) это верхний левый угол.
    pub fn set_position(&mut self, id: ObjectId, pos: Vec2) {
        self.renderer.config_position(id, pos);
    }

    /// Функция для изменения размер любого объекта по его ID
    /// (Структура ObjectId которую можно получить вызвав new_* функцию)
    /// принимает ID объекта и структуру Vec2 для описания ширины и высоты.
    pub fn set_size(&mut self, id: ObjectId, size: Vec2) {
        self.renderer.config_size(id, size);
    }

    /// Функция для конфигурации угла вращения. Принимает ID объекта
    /// и f32 в качестве угла. ИСПОЛЬЗУЕТ РАДИАНЫ, А НЕ ГРАДУСЫ!
    pub fn set_rotation(&mut self, id: ObjectId, radians: f32) {
        self.renderer.config_rotation(id, radians);
    }

    /// Функция для изменения цвета любого объекта по его ID
    /// принимает ObjectId и Vec4 из GLAM. Цвета заполняются
    /// следующим образом:
    ///     1 значение - Красный, 0-1 (Где 0 это 0, а 1 это 255 по RGBa)
    ///     2 значение - Зелёный, 0-1
    ///     3 значение - Синий  , 0-1
    ///     4 значение - Прозрачность (Альфа канал), тоже от 0 до 1
    ///
    /// Прозрачность 0 это объект не видно, 1 полностью видно,
    /// 0.5 это полупрозрачный
    pub fn set_color(&mut self, id: ObjectId, color: Vec4) {
        self.renderer.config_color(id, color);
    }

    /// Функция для конфигурации скругления у прямоугольника.
    ///     [!] Не работает для каких-либо объектов кроме прямоугольника.
    ///
    /// Принимает ID прямоугольника и Vec4 из GLAM для описания
    /// скругления каждого угла.
    ///     [*] Скругление рисуется на GPU поэтому
    ///         не стоит переживать насчёт производительности от 
    ///         его использования.
    ///
    /// Описание radii (По часовой стрелке):
    ///     1 параметр - Верхний левый угол
    ///     2 параметр - Верхний праый угол
    ///     3 параметр - Нижний правый угол
    ///     4 параметр - Нижний левый угол
    ///
    ///     [*] Про оптимизацию скругления - По факту скругление углов
    ///        ялвется чисто визуальным. У любого прямоугольника всегда
    ///        4 вершины и 6 индексов, но шейдер через алгоритм SDF
    ///        отсекает часть пикселей создавая скругление. Это очень
    ///        быстрый подход по сравнению со SKIA
    ///
    /// [?] Для создания идеального круга создайте квадрат
    ///      (ширина и высота должна быть одинаковой) и установите
    ///      скругление углов на половину ширины/высоты.
    pub fn set_rounded(&mut self, id: ObjectId, radii: Vec4) {
        self.renderer.set_rounded(id, radii);
    }
 
    /// Функция определения Z индекса объекта. Обратите внимание,
    /// z индекс никак не вляяет на размер или координаты объекта.
    /// Он нужен чтобы отсортировать объекты и определить какие
    /// объекты будут перекрывать другие.
    ///     [*] Пример:
    ///         Объект A: Z индекс = 1
    ///         Объект B: Z индекс = 2
    ///     Объект B будет перекрывать объект A
    /// Принимает Id объекта и z индекс (флоат, может быть отрицательным) 
    pub fn set_z_index(&mut self, id: ObjectId, z: f32) {
        self.renderer.set_z_index(id, z);
    }

    /// Эта функция пересоздаёт холст для рендеринга. На android
    /// при сворачивании приложение старый холст удаляется поэтому
    /// нам нужен новый.
    pub fn recreate_surface(&mut self, window: &'static (impl HasWindowHandle + HasDisplayHandle + Send + Sync), width: u32, height: u32) {
        self.renderer.recreate_surface(window, width, height);
    }
}
